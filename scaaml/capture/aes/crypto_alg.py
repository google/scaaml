# Copyright 2021-2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""AES specific SCryptoAlgorithm."""

from collections import namedtuple
from typing import Any, Type
import numpy as np

from scaaml.capture.input_generators.attack_point_iterator import build_attack_points_iterator
from scaaml.capture.crypto_alg import AbstractSCryptoAlgorithm
from scaaml.aes_forward import AESSBOX
from scaaml.io import Dataset
from scaaml.io import resume_kti

EncryptionParameters = namedtuple("EncryptionParameters", ["keys", "texts"])


class SCryptoAlgorithm(AbstractSCryptoAlgorithm):
    """Attack points and maybe some basic information about it (e.g. key
    length, etc.)."""

    def __init__(self,
                 *,
                 iterator_definition: dict[str, Any],
                 firmware_sha256: str,
                 crypto_implementation: Type[AESSBOX],
                 purpose: Dataset.SPLIT_T,
                 implementation: str = "MBEDTLS",
                 algorithm: str = "simpleserial-aes",
                 examples_per_shard: int = 64,
                 full_kt_filename: str = "parameters_tuples.txt",
                 full_progress_filename: str = "progress_tuples.txt") -> None:
        """Generates a set of key-text pairs and saves those. Does not overwrite
        existing files.

        Args:
          iterator_definition (dict[str, Any]): Definition of the iterated
          attack points, passed into `build_attack_points_iterator` of
          `scaaml.capture.input_generators.attack_point_iterator`.
          firmware_sha256: SHA256 hash of the binary used on the chip.
          crypto_implementation: The class that provides attack points info and
            attack points values (for instance scaaml.aes_forward.AESSBOX).
          purpose: Type of the dataset. Used in scaaml.io.Dataset.
          implementation: Name of the implementation that was used.
          algorithm: Algorithm name.
          examples_per_shard: Size of a single part (for ML training purposes).
          kt_filename: Filename to save key, text pairs (using resume_kti).
          progress_filename: Filename to save progress (using resume_kti).
          full_kt_filename: The file to save key-text pairs into. This should
            be in the same directory as the whole dataset.
          full_progress_filename: The file to save progress into. This should
            be in the same directory as the whole dataset.
        """
        super().__init__(firmware_sha256=firmware_sha256,
                         crypto_implementation=crypto_implementation,
                         purpose=purpose,
                         implementation=implementation,
                         algorithm=algorithm,
                         examples_per_shard=examples_per_shard,
                         full_kt_filename=full_kt_filename,
                         full_progress_filename=full_progress_filename)

        # Generate ans save key-text pairs.
        # Turn what gets generated by ktp into two arrays and save it.
        keys_list = []
        texts = []
        for attack_points in build_attack_points_iterator(iterator_definition):
            keys_list.append(attack_points["key"])
            texts.append(attack_points["plaintext"])

        # Set in get_stabilization_kti.
        self._stabilization_ktp = resume_kti.create_resume_kti(
            parameters={
                "keys":
                    np.array(keys_list[:self._examples_per_shard],
                             dtype=np.uint8),
                "texts":
                    np.array(texts[:self._examples_per_shard], dtype=np.uint8),
            },
            shard_length=np.uint64(self._examples_per_shard),
            kt_filename=self._full_kt_filename + "_stabilize.txt",
            progress_filename=self._full_progress_filename + "_stabilize.txt")
        # Does not overwrite existing keys-texts file.
        self._kti = resume_kti.create_resume_kti(
            parameters={
                "keys": np.array(keys_list, dtype=np.uint8),
                "texts": np.array(texts, dtype=np.uint8),
            },
            shard_length=np.uint64(self._examples_per_shard),
            kt_filename=self._full_kt_filename,
            progress_filename=self._full_progress_filename)
