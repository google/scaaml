# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""AES specific SCryptoAlgorithm."""
from typing import Any, Iterable, Literal, Optional
import numpy as np

from scaaml.capture.crypto_alg import AbstractSCryptoAlgorithm
from scaaml.capture.aes.acqktp import AcqKeyTextPatternScaaml as ktp_scaaml
from scaaml.io import resume_kti


class SCryptoAlgorithm(AbstractSCryptoAlgorithm):
    """Attack points and maybe some basic information about it (e.g. key
    length, etc.)."""

    def __init__(self,
                 firmware_sha256: str,
                 crypto_implementation,
                 purpose: Literal["train", "test", "holdout"],
                 implementation: str = "MBEDTLS",
                 algorithm: str = "simpleserial-aes",
                 keys: int = 3072,
                 plaintexts: int = 256,
                 repetitions: int = 1,
                 examples_per_shard: int = 64,
                 full_kt_filename: str = "key_text_pairs.txt",
                 full_progress_filename: str = "progress_pairs.txt") -> None:
        """Generates a set of key-text pairs and saves those. Does not overwrite
        existing files.

        Args:
          firmware_sha256: SHA256 hash of the binary used on the chip.
          crypto_implementation: The class that provides attack points info and
            attack points values (for instance scaaml.aes_forward.AESSBOX).
          purpose: Type of the dataset. Used in scaaml.io.Dataset.
          implementation: Name of the implementation that was used.
          algorithm: Algorithm name.
          keys: Number of different keys that are used.
          plaintexts: Number of different plaintexts used with each key.
          repetitions: Number of captures with a concrete (key, plaintext) pair.
          examples_per_shard: Size of a single part (for ML training purposes).
          kt_filename: Filename to save key, text pairs (using resume_kti).
          progress_filename: Filename to save progress (using resume_kti).
          full_kt_filename: The file to save key-text pairs into. This should
            be in the same directory as the whole dataset.
          full_progress_filename: The file to save progress into. This should
            be in the same directory as the whole dataset.
        """
        super().__init__(firmware_sha256=firmware_sha256,
                         crypto_implementation=crypto_implementation,
                         purpose=purpose,
                         implementation=implementation,
                         algorithm=algorithm,
                         keys=keys,
                         plaintexts=plaintexts,
                         repetitions=repetitions,
                         examples_per_shard=examples_per_shard,
                         full_kt_filename=full_kt_filename,
                         full_progress_filename=full_progress_filename)

        # Generate ans save key-text pairs.
        ktp = self._get_new_ktp()
        # Turn what gets generated by ktp into two arrays and save it.
        keys_list = []
        texts = []
        while True:
            try:
                # AcqKeyTextPatternScaaml.new_pair returns (key, text)
                kt_pair = ktp.new_pair()
                keys_list.append(list(kt_pair[0]))
                texts.append(list(kt_pair[1]))
            except StopIteration:
                break
        # Does not overwrite existing keys-texts file.
        self._kti = resume_kti.create_resume_kti(
            keys=np.array(keys_list, dtype=np.uint8),
            texts=np.array(texts, dtype=np.uint8),
            shard_length=np.uint64(self._examples_per_shard),
            kt_filename=self._full_kt_filename,
            progress_filename=self._full_progress_filename)
        # Set in get_stabilization_kti.
        self._stabilization_ktp: Optional[Any] = None

    def _get_new_ktp(self):
        ktp = ktp_scaaml()
        ktp.dataset = self._dataset
        ktp.plaintext_per_key = self._plaintexts
        ktp.repetitions = self._repetitions
        ktp.nb_keys = self._keys
        ktp.init(0)
        return ktp

    def get_stabilization_kti(self) -> Iterable:
        """Key-text iterator for stabilizing the capture. This is different
        from the real kti.
        """
        if self._stabilization_ktp is not None:
            return self._stabilization_ktp

        class StabilizationIterator:
            """Iterates through key-plaintext pairs used for stabilizing the
            capture."""

            def __init__(self, ktp):
                self._ktp = ktp

            def __iter__(self):
                return self

            def __next__(self):
                # AcqKeyTextPatternScaaml.new_pair raises StopIteration itself.
                kt_pair = self._ktp.new_pair()
                # Allow the same iteration as using resume_kti.
                return list(kt_pair[0]), list(kt_pair[1])

        self._stabilization_ktp = StabilizationIterator(self._get_new_ktp())
        return self._stabilization_ktp
